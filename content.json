{"pages":[],"posts":[{"title":"trial version","text":"Header123456# Head 1## Head 2### Head 3#### Head 4##### Head 5###### Head 6 수평선(Horizontal rule)123--- Hyphens*** Asterisks___ Underscores 인용구(Blockquote)123&gt; 인용문구를 나타낼 때 사용함&gt;&gt; 중첩&gt;&gt;&gt; ## 인용의 인용 인용문구를 나타낼 때 사용함 중첩 인용의 인용 목록(List)순서있는 목록, 1,2,3…순서없는 목록, -(hyphen), *(asterisks), +(plus sign) 강조(Emphasize)1234Italic: *text* or _text_Bold: **text** or __text__Cancel: ~~text~~Underline: &lt;u&gt; text &lt;/u&gt; 링크(Link)123[링크이름](링크주소)[참조링크설명][참조링크][참조링크]: 참조링크주소 &quot;링크설명 - 생략가능&quot; 이미지(Image)12![대체텍스트](링크 &quot;링크설명&quot;)[![대체텍스트](링크 &quot;링크설명&quot;)](링크주소) - 이미지에 링크 keywordslkjsdf1.sdlfkj 2. slkdjf3.lkjdf.4lkjdsf 1. scope123456789var add_the_handlers = function (nodes) { for (var i = 0; i &lt; nodes.length; i++) { nodes[i].onClick = (function (i) { return function (e) { alert(i); }; })(i); }}; conclusion…… 참고 : 블로그자바스크립트의 스코프와 클로저함수의 범위(scope)JavaScript : Scope 이해유효범위의 효용실행 컨텍스트와 자바스크립트의 동작 원리Understanding Scope and Context in JavaScriptWhat is the Difference Between Scope and Context in JavaScript?자바스크립트 클로저(Closure)에 대해서… 책자바스크립트 완벽 가이드프론트엔드 개발자를 위한 자바스크립트 프로그래밍함수형 자바스크립트","link":"/2021/02/10/trial-version/"},{"title":"#2 피보나치 함수 (백준 1003번) - 하이도비","text":"문제다음 소스는 N번째 피보나치 수를 구하는 C++ 함수이다. 1234567891011int fibonacci(int n) { if (n == 0) { printf(&quot;0&quot;); return 0; } else if (n ==1 ) { printf(&quot;1&quot;); return 1; } else { return fiboacci(n-1) + fibonacci(n-2); }} fibonacci(3)을 호출하면 다음과 같은 일이 일어난다. fibonacci(3)은 fibonacci(2)와 fibonacci(1) (첫 번째 호출)을 호출한다. fibonacci(2)는 fibonacci(1) (두 번째 호출)과 fibonacci(0)을 호출한다. 두 번째 호출한 fibonacci(1)은 1을 출력하고 1을 리턴한다. fibonacci(0)은 0을 출력하고, 0을 리턴한다. fibonacci(2)는 fibonacci(1)과 fibonacci(0)의 결과를 얻고, 1을 리턴한다. 첫 번째 호출한 fibonacci(1)은 1을 출력하고, 1을 리턴한다. fibonacci(3)은 fibonacci(2)와 fibonacci(1)의 결과를 얻고, 2를 리턴한다. 1은 2번 출력되고, 0은 1번 출력된다. N이 주어졌을 때, fibonacci(N)을 호출했을 때, 0과 1이 각각 몇 번 출력되는지 구하는 프로그램을 작성하시오. 입력첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다. N은 40보다 작거나 같은 자연수 또는 0이다. 가정사항 → 0≤N≤40 출력각 테스트 케이스마다 0이 출력되는 횟수와 1이 출력되는 횟수를 공백으로 구분해서 출력한다. 예제입력 12343013 N번째 피보나치 수를 구하는 Python 함수12345def fibonacci(n): if n &gt;= 2: return fib(n-1) + fib(n-2) else: return n fibonacci(2)나 fibonacci(3) 을 호출하면 다음과 같은 일이 일어난다. 발생되는 일의 순서는 문제에서 나타낸 것과 같다. fibonacci(2)호출→ fibonacci(2-1)과 fibonacci(2-2)가 호출되어 각각 1과 0값을 return한다. fibonacci(3)호출→ fibonacci(3-1)과 fibonacci(3-2)가 호출fibonacci(3-1)은 3-1≥2이기 때문에 fibonacci(3-1-1)과 fibonacci(3-1-2)를 호출한다.fibonacci(3-1-1)는 1을 return하고, fibonacci(3-1-2)는 0을 return한다.fibonacci(3-2)는 1을 return한다. N값에 따른 0, 1 호출 횟수는 다음과 같다. 필요 개념 - 동적 계획법 (dynamic programming, DP)수학과 컴퓨터 공학, 그리고 경제학에서 동적 계획법( dynamic programming )이란 복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법을 말한다.출처: 위키백과 특정 범위까지의 값을 구하기 위해 그것과 다른 범위까지의 값을 이용하여 효율적으로 값을 구하는 알고리즘 기법출처: 나무위키 전체 문제를 작은 문제로 단순화한다. → 부분 문제 정의 재귀적인 구조를 활용할 수 있는 점화식을 만듬 → 점화식 생성 부문 문제를 해결한 방법으로 전체 문제를 해결한다. → 문제 해결 Memoization함수의 값을 계산한 뒤 계산된 값을 배열에 저장하는 방식필요한 때마다 함수를 다시 호출하지 않고 값을 빠르게 가져올 수 있음 코드123456789101112def fibonacci(num): for i in range(2, num+1): a0.append(a0[i-1]+a0[i-2]) a1.append(a1[i-1]+a1[i-2]) print(a0[num], a1[num])n_case = int(input())for _ in range(n_case): a0 = [1, 0] a1 = [0, 1] num = int(input()) fibonacci(num)","link":"/2021/02/11/2-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%ED%95%A8%EC%88%98-%EB%B0%B1%EC%A4%80-1003%EB%B2%88-%ED%95%98%EC%9D%B4%EB%8F%84%EB%B9%84/"},{"title":"C++ 1장","text":"Objective of C++ Compatibility with CC언어로 작성된 프로그램과의 호환성을 유지한다. 객체 지향 개념 도입데이터 캡슐화, 상속, 다형성 ← 객체 지향 개념소프트웨어 재사용을 통해 소프트웨어의 생산성을 높임복잡하고 큰 규모의 소프트웨어 작성, 관리 유지 보수를 쉽게 하기 위함 엄격한 타입 체크실행 시간 요류의 가능성을 줄이고 디버깅을 도움 실행 시간 효율성 저하 최소화객체 지향 개념 도입으로 멤버 함수의 호출이 잦아지고 이로 인해 실행 시간이 저하되는 비효율성을 막기 위해 멤버 함수에 인라인 함수를 도입 New in C++ 함수 중복 (function overloading)매개 변수의 개수나 타입이 서로 다른 동일한 이름의 함수들을 선언할 수 있음 디폴트 매개 변수 (default parameter)매개 변수 값이 전달되지 않는 경우 디폴트 값이 전달되도록 함수를 선언할 수 있음 참조(reference)와 참조 변수변수에 별명을 붙여 변수 공간을 같이 사용할 수 있음 참조에 의한 호출(call-by-reference)함수 호출 시 참조를 전달할 수 있음 new와 delete 연산자동적 메모리 할당, 해제를 위한 new, delete 연산자 도입 연산자 재정의(operator overloading)기존의 연산자에 새로운 연산을 정의할 수 있음 제네릭 함수와 클래스(generics)함수나 클래스를 데이터 타입에 의존하지 않고 일반화시킬 수 있게 함 객체 지향 특성 객체와 캡슐화(Encapsulation)데이터를 캡슐(class)로 싸서 외부의 접근으로부터 데이터를 보호하는 특성캡슐 = class, 객체 = instanceclass는 멤버 변수들과 멤버 함수로 이루어지며, 멤버들은 public or private로 선언 가능 1234567class Circle { private: // 멤버들 int radius; //반지름 값 public: // 멤버들 Circle(int r) {radius = r;} double getArea() {return 3.14*radius*radius;}} 상속성(Inheritance)자식이 부모의 유전자를 물려받는 것과 유사한 개념상속 → 객체를 정의하는 클래스 사이에 상속 관계를 둠자식 클래스의 객체가 생성될 때, 자식 클래스에 선언된 멤버 + 부모 클래스에 선언된 멤버구현된 코드의 재사용성을 높임 → 소프트웨어 생산성 높임 1234567891011121314class Phone { void call(); void receive();};class MobilePhone : public Phone { # Phone을 상속 받음 void connectWireless(); void recharge();};class MusicPhone : public MobilePhone { # MobilePhone을 상속 받음 void downloadMusic(); void plya();}; 다형성 (Polymorphism)하나의 기능이 경우에 따라 서로 다르게 보이거나 다르게 작동하는 현상 - 2+3 → 5 - “남자” + “여자” → “남자여자” - redColor 객체 + blueColor 객체 → purpleColor 객체 123void add(int a, int b) {...}void add(int a, int b, int c) {...}void add(int a, double d} {...} → C++에서는 연산자 중복(operator overloading) 이라 함→ 함수가 중복되면 함수 중복(function overloading) C++ 프로그램 개발 과정source program 작성 → 컴파일(compile) → 링킹(linking) → 실행 파일(executable file) 소스 파일 → 컴파일 → 링킹 → 실행 → good→ not good → 디버깅 → 컴파일 → 링킹 → 실행 → good 컴파일(compile)소스 프로그램이 문법에 맞게 작성되었는지 검사기계어 코드로 변환하여 목적 파일(object file) 생성 링킹(linking)어떤 목적 파일이 참조하는 C++ 표준 라이브러리나 다른 목적 파일 속에 있는 함수, 객체, 데이터를 포함하여 실행에 필요한 모든 기계어 코드를 확보하여, 하나의 실행 파일로 만드는 과정 디버깅(debugging)프로그램 실행 중 오류 위치를 발견하거나 문제의 원인을 찾아 수정하는 과정디버거(debugger)라하는 특별한 소프트웨어를 이용하며, 이는 컴파일러를 공급하는 회사에서 함께 공급함 표준 라이브러리 C 라이브러리기존 C 표준 라이브러리를 수용하여 C++에서 사용할 수 있게 한 함수들cassert, cctype, cerrno, cfloat, ciso646, climits, clocale, cmath, csetjmp, csignal, cstdarg, cstddef, cstdio, cstdlib, cstring, ctime C++ 입출력 라이브러리콘솔 및 파일 입출력을 위한 함수와 클래스제네릭 프로그래밍을 지원하기 위해 템플릿으로 작성fstream, iomanip, ios, isofwd, iostream, istream, ostream, sstream, strestream, streambuf C++ STL 라이브러리제네릭 프로그래밍을 지원하기 위해 템플릿으로 작성된 유용한 함수와 클래스를 포함algorithm, bitset, complex, deque, exception, functional, iterator, limits, list, locale, map, memory, new, numeric, queue, set, stack, stdexcept, string, typeinfo, utility, valarray, vector Compile &amp; Build Compile → 목적 파일(object file) 생성 Build → compile + linking → exe 파일 생성","link":"/2021/02/10/C-1%EC%9E%A5/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/02/10/hello-world/"}],"tags":[],"categories":[{"name":"trial","slug":"trial","link":"/categories/trial/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"language","slug":"language","link":"/categories/language/"},{"name":"python","slug":"Algorithm/python","link":"/categories/Algorithm/python/"},{"name":"C++","slug":"language/C","link":"/categories/language/C/"}]}